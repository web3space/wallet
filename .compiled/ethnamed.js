// Generated by LiveScript 1.6.0
(function(){
  var Ethnamed, abi, ref$, post, get, sha3num, url, getVerifyEmailUrl, jsonParse, toHex, getContractInstance, extractSignature, getDomain, verifyEmail, getAccessKey, getPaidTransaction, getFreeTransaction, builderSetupRecord, builderWhois, builderVerifyRecord, builderSendTo, toString$ = {}.toString;
  Ethnamed = require('./addresses.json').Ethnamed;
  abi = require('./Ethnamed.abi.json');
  ref$ = require('superagent'), post = ref$.post, get = ref$.get;
  sha3num = require('solidity-sha3').sha3num;
  url = require('./config.json').url;
  getVerifyEmailUrl = require('./get-verify-email-url.ls');
  jsonParse = require('./json-parse.js');
  toHex = function(o){
    var n;
    if (o == null) {
      return o;
    }
    if (o.toString().indexOf('0x') === 0) {
      return o;
    }
    n = +o;
    return '0x' + n.toString(16);
  };
  getContractInstance = function(web3, abi, addr){
    switch (false) {
    case toString$.call(web3.eth.contract).slice(8, -1) !== 'Function':
      return web3.eth.contract(abi).at(addr);
    default:
      return new web3.eth.Contract(abi, addr);
    }
  };
  extractSignature = function(signature){
    var sig, r, s, v;
    sig = signature.slice(2);
    r = '0x' + sig.slice(0, 64);
    s = '0x' + sig.slice(64, 128);
    v = '0x' + sig.slice(128, 130);
    return {
      v: v,
      r: r,
      s: s
    };
  };
  getDomain = function(name){
    switch (false) {
    case !(name.indexOf('.') > -1):
      return name;
    default:
      return name + ".ethnamed.io";
    }
  };
  verifyEmail = function(emailkey, cb){
    var url;
    url = getVerifyEmailUrl(emailkey);
    return get(url).end(function(err, data){
      if (err != null) {
        return cb(data.text);
      }
      return jsonParse(data.text, cb);
    });
  };
  getAccessKey = function(arg$, cb){
    var name, record, domain;
    name = arg$.name, record = arg$.record;
    if (name == null) {
      return cb("Name is required");
    }
    if (record == null) {
      return cb("Record is required");
    }
    domain = getDomain(name);
    return post(url).set('name', domain).set('record', record).end(function(err, data){
      if (err != null) {
        return cb(data.text);
      }
      return jsonParse(data.text, cb);
    });
  };
  getPaidTransaction = function(web3, contract, gasLimit, amount, length, name, record, blockExpiry, owner, v, r, s){
    var toWei, ref$, ref1$, data, transaction;
    toWei = (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
      ? ref$
      : web3.toWei;
    data = (function(){
      switch (false) {
      case contract.methods == null:
        return contract.methods.setOrUpdateRecord(length, name, record, blockExpiry, owner, v, r, s).encodeABI();
      default:
        return contract.setOrUpdateRecord.getData(length, name, record, blockExpiry, owner, v, r, s);
      }
    }());
    return transaction = {
      to: Ethnamed,
      gas: toHex(gasLimit),
      value: toWei(amount + "", 'ether').toString(),
      data: data,
      decodedData: "setOrUpdateRecord(\"" + length + "\", \"" + name + "\", \"" + record + "\", \"" + blockExpiry + "\", \"" + owner + "\", \"" + v + "\", \"" + r + "\", \"" + s + "\")"
    };
  };
  getFreeTransaction = function(web3, contract, gasLimit, amount, length, name, record, blockExpiry, owner, v, r, s){
    var toWei, ref$, ref1$, data, transaction;
    toWei = (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
      ? ref$
      : web3.toWei;
    data = (function(){
      switch (false) {
      case contract.methods == null:
        return contract.methods.setOrUpdateRecord2(length, name, record, blockExpiry, owner, v, r, s).encodeABI();
      default:
        return contract.setOrUpdateRecord2.getData(length, name, record, blockExpiry, owner, v, r, s);
      }
    }());
    return transaction = {
      to: Ethnamed,
      gas: toHex(gasLimit),
      value: 0,
      data: data,
      decodedData: "setOrUpdateRecord2(\"" + length + "\", \"" + name + "\", \"" + record + "\", \"" + blockExpiry + "\", \"" + owner + "\", \"" + v + "\", \"" + r + "\", \"" + s + "\")"
    };
  };
  builderSetupRecord = function(web3, contract){
    return function(arg$, cb){
      var amountEthers, name, record, owner, toWei, ref$, ref1$;
      amountEthers = arg$.amountEthers, name = arg$.name, record = arg$.record, owner = arg$.owner;
      toWei = (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
        ? ref$
        : web3.toWei;
      return getAccessKey({
        name: name,
        record: record
      }, function(err, accessKey){
        var signature, record, name, length, blockExpiry, ref$, v, r, s, amount;
        if (owner == null) {
          return cb("Owner address is not defined");
        }
        if (err != null) {
          return cb(err);
        }
        if (accessKey == null) {
          return cb("Access keys not found");
        }
        signature = accessKey.signature, record = accessKey.record, name = accessKey.name, length = accessKey.length, blockExpiry = accessKey.blockExpiry;
        ref$ = extractSignature(signature), v = ref$.v, r = ref$.r, s = ref$.s;
        amount = (amountEthers != null ? amountEthers : "0").toString();
        return web3.eth.getBlock('latest', function(err, data){
          var gasLimit, getTransaction, transaction;
          gasLimit = +data.gasLimit - 10;
          getTransaction = (function(){
            switch (false) {
            case amount === '0':
              return getPaidTransaction;
            default:
              return getFreeTransaction;
            }
          }());
          transaction = getTransaction(web3, contract, gasLimit, amount, length, name, record, blockExpiry, owner, v, r, s);
          return web3.eth.sendTransaction(transaction, cb);
        });
      });
    };
  };
  builderWhois = function(web3, contract){
    return function(record, cb){
      var hash;
      hash = sha3num(record);
      if (contract.methods != null) {
        return contract.methods.whois(hash).call(cb);
      }
      return contract.whois(hash, cb);
    };
  };
  builderVerifyRecord = function(web3, contract){
    return function(name, cb){
      if (typeof err != 'undefined' && err !== null) {
        return cb(err);
      }
      if (contract.methods != null) {
        return contract.methods.resolve(getDomain(name)).call(cb);
      }
      return contract.resolve(getDomain(name), cb);
    };
  };
  builderSendTo = function(web3, contract){
    return function(arg$, cb){
      var amountEthers, name, toWei, ref$, ref1$, data, transaction;
      amountEthers = arg$.amountEthers, name = arg$.name;
      if (amountEthers == null) {
        return cb("Amount ETH is required");
      }
      if (name == null) {
        return cb("Name is required");
      }
      toWei = (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
        ? ref$
        : web3.toWei;
      data = (function(){
        switch (false) {
        case contract.methods == null:
          return contract.methods.sendTo(name).encodeABI();
        default:
          return contract.methods.sendTo.getData(name);
        }
      }());
      transaction = {
        to: Ethnamed,
        gas: toHex(5000000),
        value: toWei(amountEthers + "", 'ether').toString(),
        data: data,
        decodedData: "sendTo(\"" + name + "\")"
      };
      return web3.eth.sendTransaction(transaction, cb);
    };
  };
  module.exports = function(web3){
    var contract, setupRecord, verifyRecord, whois, sendTo, ref$;
    contract = getContractInstance(web3, abi, Ethnamed);
    setupRecord = builderSetupRecord(web3, contract);
    verifyRecord = builderVerifyRecord(web3, contract);
    whois = builderWhois(web3, contract);
    sendTo = builderSendTo(web3, contract);
    return ref$ = {}, import$(ref$, contract), ref$.setupRecord = setupRecord, ref$.verifyRecord = verifyRecord, ref$.whois = whois, ref$.verifyEmail = verifyEmail, ref$.sendTo = sendTo, ref$;
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
