// Generated by LiveScript 1.6.0
(function(){
  var ref$, filter, reverse, head, foldl, find, getInstallList, getPrimaryCoin, common, verifyFields, getMethods, support, replace, put, filterByImportance, getTopupAddress, toString$ = {}.toString, out$ = typeof exports != 'undefined' && exports || this;
  ref$ = require('prelude-ls'), filter = ref$.filter, reverse = ref$.reverse, head = ref$.head, foldl = ref$.foldl, find = ref$.find;
  getInstallList = require('./install-plugin.ls').getInstallList;
  getPrimaryCoin = require('./get-primary-coin.ls');
  common = [require('../web3t/plugins/gobyte-topup.ls'), require('../web3t/plugins/trycrypto-topup.ls')];
  verifyFields = function(t){
    if (t.type !== 'topup') {
      return false;
    }
    if (t.enabled !== true) {
      return false;
    }
    if (toString$.call(t.topupCoinsByMask).slice(8, -1) !== 'String') {
      return false;
    }
    if (toString$.call(t.networks).slice(8, -1) !== 'String') {
      return false;
    }
    if (toString$.call(t.token).slice(8, -1) !== 'String') {
      return false;
    }
    if (toString$.call(t.image).slice(8, -1) !== 'String') {
      return false;
    }
    if (toString$.call(t.address).slice(8, -1) !== 'String') {
      return false;
    }
    return true;
  };
  getMethods = function(){
    var base, installed;
    base = filter(verifyFields)(
    common);
    installed = filter(function(it){
      return it.type === 'topup';
    })(
    getInstallList());
    return installed.concat(base);
  };
  support = curry$(function(arg$, arg1$){
    var token, network, topupCoinsByMask, networks;
    token = arg$.token, network = arg$.network;
    topupCoinsByMask = arg1$.topupCoinsByMask, networks = arg1$.networks;
    if (networks.split(', ').indexOf(network) === -1) {
      return false;
    }
    if (topupCoinsByMask === '*') {
      return true;
    }
    if (topupCoinsByMask.split(', ').indexOf(token) > -1) {
      return true;
    }
    return false;
  });
  replace = function(params){
    return function(str, key){
      var mask;
      mask = "{" + key + "}";
      return str.replace(mask, params[key]);
    };
  };
  put = curry$(function(params, address){
    var keys;
    keys = Object.keys(params);
    if (keys.length === 0) {
      return address;
    }
    return foldl(replace(params), address)(
    keys);
  });
  filterByImportance = function(store){
    return function(arr, item){
      var coin, all, ref$, important;
      coin = getPrimaryCoin(store);
      all = arr.concat([item]);
      if ((coin != null ? (ref$ = coin.branding) != null ? ref$.topup : void 8 : void 8) == null) {
        return all;
      }
      important = find(function(it){
        var ref$;
        return it.token === (coin != null ? (ref$ = coin.branding) != null ? ref$.topup : void 8 : void 8);
      })(
      all);
      if (important != null) {
        return [important];
      }
      return all;
    };
  };
  out$.getTopupAddress = getTopupAddress = function(store, arg$){
    var token, network, address, method;
    token = arg$.token, network = arg$.network, address = arg$.address;
    method = head(
    reverse(
    filter(support({
      token: token,
      network: network
    }))(
    foldl(filterByImportance(store), [])(
    getMethods()))));
    if (method == null) {
      return null;
    }
    return put({
      token: token,
      address: address,
      network: network
    })(
    method.address);
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
